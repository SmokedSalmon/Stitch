# Message Service
Message Service provides a simple mechanism for exchanging communication data between in your main application and micro frontend application (or between in micro frontend application and micro frontend application).

## API

| Name          | Return | Description |
| ------------- | ------------- | ------------- |
| post(topic, data)  | @void  | Post data to a topic.  |
| send( topic, data, policy[optional, default='First'],timeou[optional, default=5s] )  | @Promise  | Send data to a topic, and wait response in a Promise.<br/> Options: <br/>First  - Sender will get response when first handler reply <br/>All - Sender will get response when all the handlers reply<br/> Error and timeout would be in Promise's failed part. |
| sub(topic, handler)  | @void  | Subscribe topic messages. Note:  if a topic need to response to a send action, the handler function need to return a Promise. |
| unsub(topic, handler) | @void  | Unsubscribe topic messages. |
| hasTopic(topic) | @void  | check whether a topic is exist. |

### Params

| Name  | Type  |
| :---: | :---: |
| topic | @string |
| handler | @function |
| data | @Any |
| policy | @string |
| timeout | @Number |

### The response to handler function

| Name  | Type  |  Description |
| ------------- | ------------- | ------------- |
| topic | @string | the micro frontend applications or the main applications subscribe topic, and the system topic |
| type | @string | 'Post' or 'Send' |
| policy | @string | 'First' or 'All' |
| time | @string | eg: "1639126187817" |
| sender | @string | The micro frontend application name (Same as the config lib's each app name), the main application name (Same as the config org's Product), 'Stitch' ('Stitch' means the message is from the system topic) |
| status | @string | 'Success' or 'Failed' |
| data | @any | The data pass to subscribers <br/>Send action<br/>when status is 'Success' - the data is @array<br/>when status is  'Failed', and timeout error occur the data is - { error: 'timeout error' }, if Promise error occur the data is - { error: 'promise rejection' }<br/>Post action<br/>when status is 'Success' - the data is @any<br/>when status is 'Failed',  error info show in the console eg:  [ { error:  'function - sendMoney from bankAcount has a internal error'} ]|

## Topic Name Format

Topic name has to follow below format:

MFE[:Scope]:TopicName - Defined by MFE App
the topic defined in the micro frontend application, suggested format is MFE-name + : + Topic
```js
const checkPaymentTopic = 'MFE:bankAcount:CheckPayment'; // in the bankAccount micro frontend application
```

MAIN[:Scope]:TopicName - Defined by Main App
```js
const sendAlertsTopic = 'MAIN:Alerts';
```

## Example

In your Main application

```jsx
import { stich } from 'net-ui-core';
import { createBrowserHistory } from 'history';

const config = {};
const history = createBrowserHistory();

stitch.config(config, { history });
stich.start();

const handler = async () => {
      const p3 = await new Promise(_res => setTimeout(() => _res('Confirm!'), 5000));
      return p3;
 };

const messageService = stitch.getServiceManager().getService('message_service');
const messageServiceClient = messageService.createClient(); // creat a client for the main application, then use it to communicate with the other micro frontend application
messageServiceClient.sub('MAIN:TopicA', () => handler()); // init MAIN-APP:TopicA to response the micro frontend app send action
messageServiceClient.sub('MAIN:TopicB', (res) => console(res.data)); // init MAIN-APP:TopicB to receive the micro frontend app post action
```

In your micro frontend application(the component which would use the messageService) 

```jsx
const Demo = (props) => {

  const hostContext = props.hostContext;
  const { services } = hostContext;
  const messageService= services.getService('message_service');

return (
   <div>
      <button
          onClick={() => {
            messageService.send('MAIN:TopicA', { text: ' I am MFE Application A' }).then((message) => {
                console(message.data);
              });
          }}>
              <span>send message to main app</span>
      </button>
      <button
          onClick={() => {
            messageService.post('MAIN:TopicB', { text: 'hello' });
          }}>
              <span>post a message</span>
      </button>
	</div>
  );
};
```

Unsub a topic before component unmount

```jsx
const fakeHandler = () => {};

class Demo extends React.Component {
  constructor(props) {
    super(props);
    this.state = {messageService: null};
  }

  componentDidMount() {
    this.init();
  }

  componentWillUnmount() {
	this.unsub();
  }

  initSub() {
    if(this.props.hostContext) {
    	const { services } = props.hostContext;
    	const messageService = services.getService('message_service');
      messageService.sub('MFE:Demo:TopicA', fakeHandler());
      this.setState({
            messageService: new Date()
        });
    }
  }

  unsub() {
    if(this.state.messageService) {
      this.state.messageService.unsub('MFE:Demo:TopicA', fakeHandler());
    }
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
      </div>
    );
  }
}
```
